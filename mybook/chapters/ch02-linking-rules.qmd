# 챕터 2 - Snakemake가 규칙을 연결해 줍니다!

## `input:` 블록으로 규칙 연결하기

Snakemake에게 규칙이 필요로 하는 **입력** 파일 정보를 알려주면,
규칙들을 자동으로 연결할 수 있습니다.
어떤 규칙을 실행해달라고 요청하면, Snakemake는 그 규칙에 필요한 입력 파일을
어느 규칙이 만들어내는지 자동으로 파악하고 순서에 맞게 실행해 줍니다.

`plot_comparison`과 `compare_genomes` 규칙에 입력 정보를 추가해 봅시다:

```python
rule sketch_genomes:
    output:
        "GCF_000017325.1.fna.gz.sig",
        "GCF_000020225.1.fna.gz.sig",
        "GCF_000021665.1.fna.gz.sig"
    shell: """
        sourmash sketch dna -p k=31 genomes/*.fna.gz --name-from-first
    """

rule compare_genomes:
    input:
        "GCF_000017325.1.fna.gz.sig",
        "GCF_000020225.1.fna.gz.sig",
        "GCF_000021665.1.fna.gz.sig"
    output:
        "compare.mat"
    shell: """
        sourmash compare GCF_000021665.1.fna.gz.sig \
            GCF_000017325.1.fna.gz.sig GCF_000020225.1.fna.gz.sig \
            -o compare.mat
    """

rule plot_comparison:
    message: "sourmash로 모든 입력 게놈을 비교합니다"
    input:
        "compare.mat"
    output:
        "compare.mat.matrix.png"
    shell: """
        sourmash plot compare.mat
    """

```

이제 마지막 규칙만 실행하도록 요청하면 됩니다:

```shell
snakemake -j 1 plot_comparison
```

그러면 Snakemake는 필요한 입력 파일이 없는 경우에만 앞선 규칙들을 자동으로 실행합니다.

## 잠깐 한 걸음 물러서서 생각해보기

Snakefile이 많이 길어졌지만, 그렇다고 *지나치게* 복잡해진 것은 아닙니다.
핵심은 셸 명령어들을 개별 규칙 블록으로 분리하고,
각 규칙이 어떤 파일을 만들어내는지(output)와 어떤 파일이 필요한지(input)를
명시적으로 적어준 것입니다.

이렇게 하면 불필요한 명령 재실행을 피할 수 있습니다.
현재 워크플로에서는 sourmash가 빠르기 때문에 큰 차이가 없지만,
각 단계가 1시간씩 걸리는 작업이라면, 불필요한 단계 건너뛰기가 작업 시간을 크게 단축시켜 줍니다!

또한 뒤에서 배우겠지만, 이렇게 분리된 규칙들은 재사용 가능한 빌딩 블록이 되어
서로 다른 파일을 생성하는 다양한 워크플로에 통합할 수 있습니다.
그것이 셸 명령어를 개별 규칙으로 분리해야 하는 또 다른 좋은 이유입니다!
